<html>
	<head>
		<title>Starting Code for 1st Project 2017 - with lights and textures</title>
		<style>

		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}

		canvas {
			width: 100%;
			height: 100%;
		}

	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
		<script src="models/macchina_completa.js"></script>
		<script src="models/guardrail.js"></script>
		<script src="models/albero.js"></script>
		<script src="models/strada.js"></script>

	</head>
	<body>
			<div id="blocker">
					<div id="instructions">
						<span style="font-size:40px">
								<br />								    	 
										  Time:<div class="time"></div>
										  Score:
										  <div class="score"></div>
										  <div class="instructions">
										  A-D = Move, MOUSE = Look around)
											</div>
						
					</div>
				</div>
			

		<script>

		var scene, camera, renderer, controls, stats;
		var xSpeed = 0.8;
		var ySpeed = 0.8;
		var collision=false;
		var testo2;
		var macchine= new Array(10);
		var crash=false;
		var counter;
		var a,j;
		var test1;
		var startTime, endTime;
		var objects = [];


	/*	var macchina_completa;
		var ruota;
		var ruotaGeometry;
		var ruotaMaterial;
		var muso;
		var musoGeometry;
		var musoMaterial;
		var corpo;
		var corpoGeometry;
		var corpoMaterial;
		var alaAnteriore;
		var alaAnterioreGeometry;
		var alaAnterioreMaterial;
		var retro;
		var retroGeometry;
		var retroMaterial;
		var alettone;
		var alettoneGeometry;
		var alettoneMaterial;
		var tetto;
		var tettoGeometry;
		var tettoMaterial;

		var colore;
		*/
		//var loader = new THREE.OBJLoader();

		function Start() {
			j=0;
			a=60;
			test1=true;
			counter=0;
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );

			camera.position.set(-20,6,0);
			camera.lookAt( new THREE.Vector3(0,0,0));

			var geometry = new THREE.BoxGeometry(1,1,1);
			var texture = THREE.ImageUtils.loadTexture('textures/11635.jpg');
			var material = new THREE.MeshPhongMaterial( { map: texture } );
			var cube = new THREE.Mesh( geometry, material );
			cube.castShadow = true;
			cube.receiveShadow = true;

			//scene.add( cube );

			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );

			dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.position.multiplyScalar( 50 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;


			// GROUND
			
			var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
			var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
			groundMat.color.setHSL( 0.095, 1, 0.75 );
			var ground = new THREE.Mesh( groundGeo, groundMat );
			ground.position.y = -0.5;
			ground.rotation.x = -Math.PI/2;
			//scene.add( ground );
			ground.receiveShadow = true;

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			// uncomment if you need to draw coordinate axes when building the scene
			//Coordinates.drawAllAxes();

			controls = new THREE.OrbitControls( camera );
			//controls.addEventListener( 'change', Render );

			/*for (var i=0;i<10;i++){
				macchine[i]=creaMacchinaCompleta();
				scene.add(macchine[i]);
				macchine[i].position.set(getRandomInt(450,50),0,getRandomInt(10,-10));
				//macchine[i].rotation.y=Math.PI;
			}
*/
			macchinaCompleta=creaMacchinaCompleta();
			//let macchinaCompleta=macchinaCompletaGeometry.getMacchinaCompleta();
			scene.add(macchinaCompleta);
			macchinaCompleta.position.set(-5,0.4,0);

			albero = creaAlbero();
			scene.add(albero);
			albero.position.set(100,4,15);
			albero2 = creaAlbero();
		//	scene.add(albero2);
			albero2.position.set(169,4,10);

			guardRailDx=creaGuardRail();
			scene.add(guardRailDx);
			guardRailDx.position.set(30,0.8,10.8);

			guardRailSx=creaGuardRail();
			scene.add(guardRailSx);
			guardRailSx.position.set(30,0.8,-6.8);

			strada=creaStrada();
			scene.add(strada);
			strada.position.set(25,0.01,2)

			var fontLoader = new THREE.FontLoader();
			fontLoader.load( 'fonts/helvetiker_bold.typeface.json', function ( font ) {

			var testo = new THREE.TextGeometry( 'GAME OVER', {
				font: font,
				size: 16,
				height: 2,
				curveSegments: 8,
			} );
			

			var colore2=new THREE.Color();
			colore2.setRGB(0,0,250);
			var textMaterial= new THREE.MeshBasicMaterial({ color: colore2 });
    		testo2 = new THREE.Mesh(testo , textMaterial);
			scene.add(testo2);
			testo2.position.set(50,100,0);
			testo2.rotation.y=Math.PI/(2/3);
			testo2.translateX(-60);
		} );



		/*	//inizio here

			macchina_completa = new THREE.Object3D();

			colore=(Math.random()*0xffffff);

			corpoGeometry = new THREE.BoxGeometry(4,1,2);
			corpoMaterial = new THREE.MeshBasicMaterial({ color: colore, side: THREE.DoubleSide } );
			corpo=new THREE.Mesh(corpoGeometry,corpoMaterial);
			corpo.position.set(-1,0,0);

			musoGeometry = new THREE.BoxGeometry(3,1,1);
			musoMaterial = new THREE.MeshBasicMaterial({ color: colore, side: THREE.DoubleSide } );
			muso=new THREE.Mesh(musoGeometry,musoMaterial);
			//muso.add(tetto);
			muso.position.set(2.5,0,0);

			alaAnterioreGeometry=new THREE.BoxGeometry(1,1,3);
			alaAnterioreMaterial = new THREE.MeshBasicMaterial({ color: colore, side: THREE.DoubleSide } );
			alaAnteriore=new THREE.Mesh(alaAnterioreGeometry,alaAnterioreMaterial);
			alaAnteriore.position.set(4.5,0,0);

			retroGeometry=new THREE.BoxGeometry(3,1,1);
			retroMaterial = new THREE.MeshBasicMaterial({ color: colore, side: THREE.DoubleSide } );
			retro=new THREE.Mesh(retroGeometry,retroMaterial);
			retro.position.set(-4.5,0,0);

			tettoGeometry=new THREE.BoxGeometry(3,1,1)
			tettoMaterial = new THREE.MeshBasicMaterial({ color: colore, side: THREE.DoubleSide } );
			tetto=new THREE.Mesh(tettoGeometry,tettoMaterial);
			tetto.position.set(-2,1,0);

			alettone=new THREE.Mesh(alaAnterioreGeometry,alaAnterioreMaterial); //alettone=ala anteriore
			alettone.position.set(-5.5,1,0);

			ruotaGeometry=new THREE.BoxGeometry(1,1,1);
			ruotaMaterial = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide } );
			ruota=[];
			for (i=0; i<4; i++){
				ruota[i] = new THREE.Mesh(ruotaGeometry,ruotaMaterial);
				macchina_completa.add(ruota[i]);
			}
			ruota[0].position.set(2.5,0,1);
			ruota[1].position.set(2.5,0,-1);
			ruota[2].position.set(-4,0,1);
			ruota[3].position.set(-4,0,-1);


			macchina_completa.add(tetto);
			macchina_completa.add(alettone);
			macchina_completa.add(retro);
			macchina_completa.add(alaAnteriore);
			macchina_completa.add(muso);
			macchina_completa.add(corpo);
			macchina_completa.position.set(-50,0,0)
			*/
			//scene.add(macchina_completa);
			setGround();
		}
		function spawnMacchine(variabile){
			console.log("insidee");
			
			if(variabile %a===0){
				if(a!=8){
				a--;
				}
				macchine[j]=creaMacchinaCompleta();
				scene.add(macchine[j]);
			    macchine[j].position.set(getRandomInt(200,50),0.4,getRandomInt(10,-5));
				j++;
			}
		}
		function detectCollisionCubes(object1, object2){
			object1.geometry.computeBoundingBox(); //not needed if its already calculated
  			object2.geometry.computeBoundingBox();
  			object1.updateMatrixWorld();
  			object2.updateMatrixWorld();

  			var box1 = object1.geometry.boundingBox.clone();
  			box1.applyMatrix4(object1.matrixWorld);

  			var box2 = object2.geometry.boundingBox.clone();
			box2.applyMatrix4(object2.matrixWorld);

			return box1.intersectsBox(box2);
		}
		function crashed(counter){
			if(test1==true){
			//camera.rotation.y=Math.PI+0.5;
			camera.position.y=100;
			//camera.rotation.x=0.2;
			/*
			testo2.position.x=-15;
			testo2.rotation.x=0.1;
			testo2.rotation.z=0.1;
			testo2.translateZ(-50);
			testo2.translateX(-40);
			*/
			document.querySelector('.score').innerHTML = counter;
			test1=false;
		}
		}
	

		

		function Update() {
			
			counter++;
			document.querySelector('.time').innerHTML = counter;
			spawnMacchine(counter);
			//console.log(counter);


			if(macchinaCompleta.position.z>=9||macchinaCompleta.position.z<=-5){crashed(counter);
			}
		for (var i=0;i<j;i++){
		if(detectCollisionCubes(macchinaCompleta,macchine[i])==true){


			console.log("HIT");
			macchine[i].position.x=-1500;
			crashed(counter);

		}else{
			macchine[i].position.x -=4;
			albero.position.x -=0.3;
			albero2.position.x -=0.3;

		}
		if(macchine[i].position.x<-20){
			macchine[i].position.x=-1500;
			//removeEntity(macchine[i]);
		}
		}
				//if(crash==true){


			//	}
				requestAnimationFrame( Update );
				//controls.update();
				stats.update();

				Render();


		}
		//}
		function getRandomInt(max,min) {
			var a;
			a=Math.floor(Math.random() * Math.floor(max));
			if(Math.random()<=0.5){
				a=-a
			}
			if (a<min){
			}else{
 		 return a
			}
		}

		function getHeightData(img,scale) {
  
  			if (scale == undefined) scale=1;

			var canvas = document.createElement( 'canvas' );
			canvas.width = img.width;
			canvas.height = img.height;
			var context = canvas.getContext( '2d' );

			var size = img.width * img.height;
			console.log(size);
			var data = new Float32Array( size );

			context.drawImage(img,0,0);

			for ( var i = 0; i < size; i ++ ) {
				data[i] = 0
			}

			var imgd = context.getImageData(0, 0, img.width, img.height);
			var pix = imgd.data;

			var j=0;
			for (var i = 0; i<pix.length; i +=4) {
				var all = pix[i]+pix[i+1]+pix[i+2];  // all is in range 0 - 255*3
				data[j++] = scale*all/3;   
			}

	 return data;
 		}
		 function setGround() {
				terrain = new THREE.Object3D();
				img = new Image();
				img.src = "textures/heightmap.png";
				img.onload = function () {
					var data = getHeightData(img,0.1);
					let count = 0;
					var boxGeometry = new THREE.BoxBufferGeometry( 1, 1, 1 );
					let boxMountainTex=new THREE.TextureLoader().load('textures/11635.jpg');
					let boxMountainMat=  new THREE.MeshBasicMaterial( { map: boxMountainTex } );
					let boxMountain = new THREE.Mesh( boxGeometry, boxMountainMat);
					for (var i = 0; i < img.width; i++) {
						for (var j = 0; j < img.height; j++) {
							
							let object=boxMountain.clone();
							object.position.x = ( i - img.width / 2 );
							object.position.z = ( j - img.height / 2 );
							object.position.y = data[count] * 1;
							
							count++;
							
							objects.push(object);
							terrain.add(object);
						}
					}

					scene.add(terrain);
					terrain.position.y=-0.8;
					terrain.position.x=30;
					terrain.rotation.y=Math.PI;
				}
		}

		function Render() {

			renderer.render(scene, camera);
		}


		document.addEventListener("keydown", onDocumentKeyDown, false);

		function onDocumentKeyDown(event) { //WASD to move
		var keyCode = event.which;
		if (keyCode == 65) {
			macchinaCompleta.position.z -= xSpeed;
			camera.position.z-=xSpeed;
		} else if (keyCode == 68) {
			macchinaCompleta.position.z += xSpeed;
			camera.position.z+=xSpeed;
		}

		};

		Start();
		Update();



		</script>
		
	</body>
</html>
